// generated by Claude Sonnet 4.5
const fs = require('fs');
const path = require('path');

/**
 * è‡ªåŠ¨åŒæ­¥ @react-native-ohos å’Œ @react-native-oh-tpl åŒ…çš„ harmony.alias é…ç½®åˆ° tsconfig.json
 * è¿™æ ·å°±ä¸éœ€è¦æ‰‹åŠ¨ä¸ºæ¯ä¸ªåŒ…é…ç½®è·¯å¾„æ˜ å°„
 */

const ROOT_DIR = path.join(__dirname, '..');
const TSCONFIG_PATH = path.join(ROOT_DIR, 'tsconfig.json');
const NODE_MODULES = path.join(ROOT_DIR, 'node_modules');

// éœ€è¦æ‰«æçš„ç›®å½•
const SCOPES_TO_SCAN = ['@react-native-ohos', '@react-native-oh-tpl'];

// è¦æ’é™¤çš„å®Œæ•´åŒ…åï¼ˆæ ¼å¼ï¼š"scope/pkg"ï¼‰
const EXCLUDED_PACKAGES = ['@react-native-ohos/react-native-securerandom'];

/**
 * æ‰«ææŒ‡å®šä½œç”¨åŸŸä¸‹çš„æ‰€æœ‰åŒ…ï¼Œæå– harmony.alias é…ç½®
 */
function extractHarmonyAliases() {
  const aliases = {};

  for (const scope of SCOPES_TO_SCAN) {
    const scopePath = path.join(NODE_MODULES, scope);
    
    if (!fs.existsSync(scopePath)) {
      console.log(`âš ï¸  ä½œç”¨åŸŸ ${scope} ä¸å­˜åœ¨ï¼Œè·³è¿‡`);
      continue;
    }

    const packages = fs.readdirSync(scopePath);

    for (const pkg of packages) {
      const fullPackageName = `${scope}/${pkg}`;
      if (EXCLUDED_PACKAGES.includes(fullPackageName)) {
        console.log(`â¤« è·³è¿‡è¢«æ’é™¤çš„åŒ… ${fullPackageName}`);
        continue;
      }
      const packageJsonPath = path.join(scopePath, pkg, 'package.json');
      
      if (!fs.existsSync(packageJsonPath)) {
        continue;
      }

      try {
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
        
        if (packageJson.harmony && packageJson.harmony.alias) {
          const alias = packageJson.harmony.alias;
          const targetPath = `./node_modules/${scope}/${pkg}`;
          
          aliases[alias] = [targetPath];
        }
      } catch (error) {
        console.error(`âœ— è¯»å– ${packageJsonPath} å¤±è´¥:`, error.message);
      }
    }
  }

  return aliases;
}

/**
 * æ›´æ–° tsconfig.json ä¸­çš„ paths é…ç½®
 */
function updateTsConfig(aliases) {
  if (Object.keys(aliases).length === 0) {
    console.log('\nâš ï¸  æœªæ‰¾åˆ°ä»»ä½• harmony.alias é…ç½®');
    return;
  }

  try {
    const tsconfig = JSON.parse(fs.readFileSync(TSCONFIG_PATH, 'utf-8'));
    
    if (!tsconfig.compilerOptions) {
      tsconfig.compilerOptions = {};
    }

    if (!tsconfig.compilerOptions.paths) {
      tsconfig.compilerOptions.paths = {};
    }

    // å¦‚æœæœ‰ baseUrlï¼Œéœ€è¦è°ƒæ•´è·¯å¾„ä¸ºç›¸å¯¹äº baseUrl
    const baseUrl = tsconfig.compilerOptions.baseUrl || '.';
    const adjustedAliases = {};
    
    for (const [alias, [targetPath]] of Object.entries(aliases)) {
      // è®¡ç®—ä» baseUrl åˆ° node_modules çš„ç›¸å¯¹è·¯å¾„
      if (baseUrl === './src' || baseUrl === 'src') {
        adjustedAliases[alias] = ['../node_modules/' + targetPath.replace('./node_modules/', '')];
      } else {
        adjustedAliases[alias] = [targetPath];
      }
    }

    // åˆå¹¶åˆ«åï¼Œä¿ç•™å·²æœ‰çš„é harmony ç›¸å…³çš„è·¯å¾„é…ç½®
    const updatedPaths = { ...tsconfig.compilerOptions.paths };
    
    for (const [alias, target] of Object.entries(adjustedAliases)) {
      updatedPaths[alias] = target;
    }

    tsconfig.compilerOptions.paths = updatedPaths;

    // å†™å…¥æ–‡ä»¶ï¼Œä¿æŒæ ¼å¼
    fs.writeFileSync(
      TSCONFIG_PATH,
      JSON.stringify(tsconfig, null, 2) + '\n',
      'utf-8'
    );

    console.log(`\nâœ… æˆåŠŸæ›´æ–° tsconfig.jsonï¼Œå…±é…ç½® ${Object.keys(aliases).length} ä¸ªåˆ«å`);
  } catch (error) {
    console.error('âœ— æ›´æ–° tsconfig.json å¤±è´¥:', error.message);
    process.exit(1);
  }
}

// æ‰§è¡Œè„šæœ¬
console.log('ğŸ” å¼€å§‹æ‰«æ harmony.alias é…ç½®...\n');
const aliases = extractHarmonyAliases();
updateTsConfig(aliases);
